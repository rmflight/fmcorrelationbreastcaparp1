# Overlap with Histone Marks within Transcription Start Sites

The histone peaks will be read in from the right files. 

```{r setupKnitr, echo=FALSE, results='hide'}
knitr::opts_chunk$set(dev='CairoPNG')
```

```{r use_dir}
data_dir <- "/mlab/data/rmflight/Documents/projects/work/fondufe-mittendorf_lab/parp1_data"
library(GenomicRanges)
library(magrittr)
options(mc.cores = 10)
library(parallel)
library(ggplot2)
library(parp1)
library(BiocParallel)
library(BSgenome.Hsapiens.UCSC.hg19)
```

In the initial analysis, we will use the TSS windows. 

```{r load_tss_parp1}
load(file.path(data_dir, "tss_windows.RData"))
load(file.path(data_dir, "ln4_reads_unique.RData"))
load(file.path(data_dir, "ln5_reads_unique.RData"))
```

Calculate the weighted coverage of the ln4 and ln5 sample reads, and then sum the reads in each TSS window.

```{r ln4_ln5_counts}
ln4_cov <- coverage(ln4_unique, weight = "n_count")
ln5_cov <- coverage(ln5_unique, weight = "n_count")

tss_windows <- binned_function(tss_windows, ln4_cov, "sum", "ln4_read")
tss_windows <- binned_function(tss_windows, ln5_cov, "sum", "ln5_read")
```


```{r read_histone}
histone_files <- file.path(data_dir, dir(data_dir, pattern = "CTCF_narrow_peak_H"))
histone_names <- strsplit(histone_files, "_") %>% sapply(., function(x){x[6]})
histone_names <- strtrim(histone_names, nchar(histone_names) - 4)

names(histone_files) <- histone_names

for (i_histone in histone_names){
	tmp <- read.table(histone_files[i_histone], header = TRUE, sep = ",")
	names(tmp) <- c("chrom", "start", "end", "name", "score", "strand", "signal", "pvalue", "qvalue", "other", "id")
	 histone_tmp <- GRanges(seqnames = tmp$chrom,
				          ranges = IRanges(start = tmp$start, end = tmp$end),
					            mcols = DataFrame(tmp[, c("score", "signal", "pvalue")]), overlap = 0, overlap_ratio = 0)
	rm(tmp)

	histone_cov <- coverage(histone_tmp, weight = "mcols.signal")
	tss_windows <- binned_function(tss_windows, histone_cov, "mean_nozero", i_histone)
}
#histone_data <- GRangesList(histone_data)
```

Now with the Parp1 reads and histone mark signal added to the TSS's, we can start doing some correlations.


```{r graphit}
h3k04me3k_v_ln4 <- subsample_nonzeros(mcols(tss_windows), c("H3k04me3k", "ln4_read"), non_zero = "either", n_points = 10000)
ggplot(h3k04me3k_v_ln4, aes(x = H3k04me3k, y = ln4_read)) + geom_point() + scale_y_log10() + scale_x_log10()
cor(log10(h3k04me3k_v_ln4[,1]+1), log10(h3k04me3k_v_ln4[,2]+1))

h3k27ac_v_ln4 <- subsample_nonzeros(mcols(tss_windows), c("H3K27ac", "ln4_read"), non_zero = "either", n_points = 10000)
ggplot(h3k27ac_v_ln4, aes(x = H3K27ac, y = ln4_read)) + geom_point() + scale_y_log10() + scale_x_log10()
cor(log10(h3k27ac_v_ln4[,1]+1), log10(h3k27ac_v_ln4[,2]+1))
```

Cool. Now we are showing some promise. Let's do them all.

```{r grab_all}
all_comb <- expand.grid(c("H3k04me3k", "H3K27ac", "H3K27me3", "H3K36me3", "H3K9me3"), c("ln4_read", "ln5_read"), stringsAsFactors = FALSE)
out_cor <- lapply(seq(1, nrow(all_comb)), function(i_row){
  #print(i_row)
  correlate_non_zero(mcols(tss_windows), as.character(all_comb[i_row,]), log_transform = TRUE, test = TRUE)
})
all_comb_names <- paste(all_comb[,1], all_comb[,2], sep = "_v_")
out_cor <- do.call(rbind, out_cor)
rownames(out_cor) <- all_comb_names
out_cor
```

```{r graphs}
out_graphs <- lapply(seq(1, nrow(all_comb)), function(i_row){
  use_vars <- as.character(all_comb[i_row,])
  subpoints <- subsample_nonzeros(mcols(tss_windows), use_vars, non_zero = "either", n_points = 10000)
  ggplot(subpoints, aes_string(x = use_vars[1], y = use_vars[2])) + geom_point() + scale_y_log10() + scale_x_log10()
})
```


### Genome Wide Comparison

Are these correlations a result of association with the TSS's? One way to test this is to set up a calculation genome-wide.

```{r genome_tiles}
genome_tiles <- tileGenome(seqinfo(Hsapiens), tilewidth = 2000, cut.last.tile.in.chrom = TRUE)

genome_tiles <- binned_function(genome_tiles, ln4_cov, "sum", "ln4_read")
genome_tiles <- binned_function(genome_tiles, ln5_cov, "sum", "ln5_read")
```

```{r genome_histone_marks}
for (i_histone in histone_names){
  tmp <- read.table(histone_files[i_histone], header = TRUE, sep = ",")
	names(tmp) <- c("chrom", "start", "end", "name", "score", "strand", "signal", "pvalue", "qvalue", "other", "id")
	histone_tmp <- GRanges(seqnames = tmp$chrom,
				          ranges = IRanges(start = tmp$start, end = tmp$end),
					            mcols = DataFrame(tmp[, c("score", "signal", "pvalue")]), overlap = 0, overlap_ratio = 0)
	rm(tmp)

	histone_cov <- coverage(histone_tmp, weight = "mcols.signal")
	genome_tiles <- binned_function(genome_tiles, histone_cov, "mean_nozero", i_histone)
}
```

```{r genome_graph_test}
genome_h3k04me3k_v_ln4 <- subsample_nonzeros(mcols(genome_tiles), c("H3k04me3k", "ln4_read"), non_zero = "either", n_points = 10000)
ggplot(genome_h3k04me3k_v_ln4, aes(x = H3k04me3k, y = ln4_read)) + scale_x_log10() + scale_y_log10() + geom_point()
```

```{r genome_cor}
genome_cor <- lapply(seq(1, nrow(all_comb)), function(i_row){
  #print(i_row)
  correlate_non_zero(mcols(genome_tiles), as.character(all_comb[i_row,]), log_transform = TRUE, test = TRUE)
})
all_comb_names <- paste(all_comb[,1], all_comb[,2], sep = "_v_")
genome_cor <- do.call(rbind, genome_cor)
rownames(genome_cor) <- all_comb_names
genome_cor
```

