# Overlap with Histone Marks within Transcription Start Sites

The methylation peaks will be read in from the right files. 

```{r setupKnitr, echo=FALSE, results='hide'}
knitr::opts_chunk$set(dev='CairoPNG')
```

```{r use_dir}
data_dir <- "/mlab/data/rmflight/Documents/projects/work/fondufe-mittendorf_lab/parp1_data"
library(GenomicRanges)
library(magrittr)
options(mc.cores = 10)
library(parallel)
library(ggplot2)
library(rmfNotifier)
library(parp1)
library(BiocParallel)
```

Based on previous manuscripts, it may be a good idea to restrict both the methylation and parp1 reads to a 2kb window surrounding annotated transcription start sites (tss). 

```{r read_tss}
tss_file <- file.path(data_dir, "ensGene_TTSS.csv")
tss_data <- read.table(tss_file, header = TRUE, sep = ",", stringsAsFactors = FALSE)
tss_regions <- GRanges(seqnames = tss_data$chrom,
                       strand = tss_data$strand,
                       ranges = IRanges(start = tss_data$txStart,
                                        end = tss_data$txEnd),
                       names = tss_data$name)
rm(tss_data)
```

Generate 2kb regions around each *tss*.

```{r windowed_tss}
tss_windows <- GRanges(seqnames = seqnames(tss_regions),
                       strand = strand(tss_regions),
                       ranges = IRanges(start = start(tss_regions) - 1000,
                                        end = start(tss_regions) + 1000))
names(tss_windows) <- mcols(tss_regions)$names
```

Now we read in the methylation data.

```{r read_methylation}
methyl_files <- file.path(data_dir, dir(data_dir, pattern = "CTCF_narrow_peak_H"))
methyl_names <- strsplit(methyl_files, "_") %>% sapply(., function(x){x[6]})
methyl_names <- strtrim(methyl_names, nchar(methyl_names) - 4)

names(methyl_files) <- methyl_names

methyl_data <- mclapply(methyl_files, function(x){
  tmp <- read.table(x, header = TRUE, sep = ",")
  names(tmp) <- c("chrom", "start", "end", "name", "score", "strand", "signal", "pvalue", "qvalue", "other", "id")
  methyl_tmp <- GRanges(seqnames = tmp$chrom,
          ranges = IRanges(start = tmp$start, end = tmp$end),
          mcols = DataFrame(tmp[, c("score", "signal", "pvalue")]), overlap = 0, overlap_ratio = 0)
  rm(tmp)
  
  methyl_overlap <- findOverlaps(methyl_tmp, tss_windows, minoverlap = 80, ignore.strand = TRUE)
  methyl_2_tss <- split(methyl_tmp[queryHits(methyl_overlap)], names(tss_windows)[subjectHits(methyl_overlap)])
  
  methyl_vals <- bplapply(methyl_2_tss, function(in_tss){
    average_value(in_tss)
  })
  methyl_vals <- unlist(methyl_vals)
  methyl_vals
})
#methyl_data <- GRangesList(methyl_data)
```

We will also get the total number of reads from *LN4* and *LN5* samples.

```{r}
total_reads <- c(ln4 = 60228591, ln5 = 53669637)
```


Now lets go through the *parp1* nucleosome data. For each chromosome, we will count those reads that are within the 2kb TSS window, assuming that the reads correspond to nucleosomes.

```{r get_chromosome_within_tss}
ln4_files <- file.path(data_dir, dir(data_dir, pattern = "ln4_chr"))

ln4_overlap <- get_overlap_counts(ln4_files, tss_windows)

ln5_files <- file.path(data_dir, dir(data_dir, pattern = "ln5_chr"))
ln5_overlap <- get_overlap_counts(ln5_files, tss_windows)
```

So now we will create the `DataFrame` that can be added to the original transcript start site windows.

```{r methyl_sample_dataframe}
n_tss <- length(tss_windows)
overlap_values <- DataFrame(matrix(0, nrow = n_tss, ncol = length(methyl_data) + 4), row.names = names(tss_windows))

colnames(overlap_values) <- c(names(methyl_data), "ln4", "ln5", "ln4_frac", "ln5_frac")

for (i_name in names(methyl_data)){
  use_names <- names(methyl_data[[i_name]])
  overlap_values[use_names, i_name] <- methyl_data[[i_name]]
}

overlap_values[names(ln5_overlap), "ln5"] <- ln5_overlap
overlap_values[names(ln4_overlap), "ln4"] <- ln4_overlap
overlap_values[, "ln4_frac"] <- overlap_values[, "ln4"] / total_reads["ln4"]
overlap_values[, "ln5_frac"] <- overlap_values[, "ln5"] / total_reads["ln5"]
```


Now with the counts in place, we can graph the data and see what we have. Because we have so many points, we will use a sub-sample of 10000 points to see what exactly is going on.

```{r graphit}
h3k04me3k_v_ln4 <- subsample_nonzeros(overlap_values, c("H3k04me3k", "ln4"), non_zero = "both", n_points = 10000)
ggplot(h3k04me3k_v_ln4, aes(x = H3k04me3k, y = ln4)) + geom_point() + scale_y_log10() + scale_x_log10()
cor(log10(h3k04me3k_v_ln4[,1]), log10(h3k04me3k_v_ln4[,2]))

h3k27ac_v_ln4 <- subsample_nonzeros(overlap_values, c("H3K27ac", "ln4"), non_zero = "both", n_points = 10000)
ggplot(h3k27ac_v_ln4, aes(x = H3K27ac, y = ln4)) + geom_point() + scale_y_log10() + scale_x_log10()
cor(log10(h3k27ac_v_ln4[,1]), log10(h3k27ac_v_ln4[,2]))
```

Cool. Now we are showing some promise. Let's do them all.

```{r grab_all}
all_comb <- expand.grid(names(methyl_data), c("ln4", "ln4_frac", "ln5", "ln5_frac"), stringsAsFactors = FALSE)
out_cor <- lapply(seq(1, nrow(all_comb)), function(i_row){
  print(i_row)
  correlate_non_zero(overlap_values, as.character(all_comb[i_row,]), log_transform = TRUE, test = TRUE)
})
all_comb_names <- paste(all_comb[,1], all_comb[,2], sep = "_v_")
out_cor <- do.call(rbind, out_cor)
rownames(out_cor) <- all_comb_names
out_cor
```

```{r graphs}
out_graphs <- lapply(seq(1, nrow(all_comb)), function(i_row){
  use_vars <- as.character(all_comb[i_row,])
  subpoints <- subsample_nonzeros(overlap_values, use_vars, non_zero = "both", n_points = 10000)
  ggplot(subpoints, aes_string(x = use_vars[1], y = use_vars[2])) + geom_point() + scale_y_log10() + scale_x_log10()
})
```
